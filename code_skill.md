## 链表  
1. 冗余头节点法： 用于解决判断原始头节点是否为空的问题，减少了一次判断，代码更简洁。  

## 字符串  
2. 游标法： 用i,j两个游标分别标识当前判断子串的首尾位置，并不断移动游标。可以省略大量拷贝子串的空间。  

## 动态规划  
* 确定状态转移方程  
* 二维矩阵要先初始化原点，再初始化首行和首列，最后再遍历更新  

## python技巧  
* 矩阵拼接直接用相加, 不要用extend
```python
a = [1, 2, 3]
b = a + a  # [1, 2, 3, 1, 2, 3]
```   

## 查找数字是否存在  
1. 二维数组查找，数组从左到右，从上到下都是递增
    O(m + n): 从左下角开始，数字偏大就上移，偏小就右移。
    暴力法: 把二维矩阵拼成一个大数组，return target in array
    注意：实际处理时暴力法的耗时更少   
    

## 二进制
1. 获取数字的二进制1的个数，负数用补码表示  
    一般思路： 用n & (n - 1) 消除最末尾的1，计数
    python: 获取二进制bin(n), 可以直接bin(n).count('1')。问题在于负数时的处理。负数要用32-bin(abs(n) - 1).count('1')。我觉得这个32纯粹手动模拟C处理。
    
